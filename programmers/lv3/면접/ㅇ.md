# Network

## Table of Contents

-   [TCP와 UDP의 차이](#tcp와-udp의-차이)
-   [TCP 흐름제어](#tcp-흐름제어)
-   [TCP 혼잡제어](#tcp-혼잡제어)
-   [TCP 3-way handshake가 언제 일어나고 어떤 과정인지](#tcp-3-way-handshake가-언제-일어나고-어떤-과정인지)
-   [TCP 4-way handshake가 언제 일어나고 어떤 과정인지](#tcp-4-way-handshake가-언제-일어나고-어떤-과정인지)
-   [OSI 7계층과 각 계층의 역할](#osi-7계층과-각-계층의-역할)
-   [CDN과 사용 시의 이점](#cdn과-사용-시의-이점)
-   [로드 밸런싱](#로드-밸런싱)
-   [CIDR](#cidr)
-   [HTTP 특징](#http-특징)
-   [HTTP 1, 2, 3의 차이](#http-1-2-3의-차이) \*
-   [HTTP 상태코드](#http-상태코드)
-   [HTTP와 HTTPS(HTTP Secure)의 차이](#http와-httpshttp-secure의-차이)
-   [SSL(Secure Sockets Layer) 동작방식](#sslsecure-sockets-layer-동작방식)
-   [TLS(Transport Layer Security) 동작방식](#tlstransport-layer-security-동작방식) \*
-   [HSTS(HTTP Strict Transport Security)](#hstshttp-strict-transport-security)
-   [쿠키와 세션](#쿠키와-세션)
-   [캐시](#캐시)
-   [JWT](#jwt)
-   [웹 브라우저에 URL을 입력했을 때의 수행 과정](#웹-브라우저에-url을-입력했을-때의-수행-과정)
-   [기타 네트워크 프로토콜과 기본 네트워크 주소들](#기타-네트워크-프로토콜과-기본-네트워크-주소들)
-   [웹 캐시](#웹-캐시)
-   [URI, URL, URN](#uro-url-urn)
-   [REST](#rest)
-   [REST API](#rest-api)
-   [REST API 장단점](#rest-api-장단점)
-   [RESTful](#restful)
-   [HTTP GET 방식과 POST 방식의 차이](#http-get-방식과-post-방식의-차이)
-   [HTTP POST 방식과 PUT 방식의 차이](#http-post-방식과-put-방식의-차이)
-   [HTTP 멱등성](#http-멱등성)
-   [웹 브라우저에 HTTP 응답이 랜더링되는 과정](#웹-브라우저에-http-응답이-랜더링되는-과정) \*
* [URL을 입력하고 벌어지는 일](#URL을-입력하고-벌어지는-일)

*   [배열과 리스트 비교](#배열과-리스트-비교)
*   [배열과 링크드 리스트 비교](#배열과-링크드-리스트-비교)
*   [배열 리스트와 링크드 리스트 비교](#배열-리스트와-링크드-리스트-비교)
*   [해시 테이블](#해시-테이블)
*   [Stack과 Queue](#stack과-queue)
*   [Tree](#tree)
*   [힙](#힙)
*   [Binary Search Tree의 최악의 시간복잡도와 최악의 시간복잡도를 유발하는 케이스](#binary-search-tree의-최악의-시간복잡도와-최악의-시간복잡도를-유발하는-케이스)
*   [Graph 자료구조](#graph-자료구조)
*   [Graph를 구현하는 두 가지 방법과 장점](#graph를-구현하는-두-가지-방법과-장점)

# OOP(Object-Oriented Programming)

## Table of Content

-   [자바, C++, C, Python](#자바-c++-c-python)
-   [객체지향 프로그래밍과 장점](#객체지향-프로그래밍과-장점)
-   [객체지향과 절차지향](#객체지향과-절차지향)
-   [객체](#객체)
-   [객체지향 프로그래밍의 특징](#객체지향-프로그래밍의-특징)
-   [Overriding과 Overloading](#overriding과-overloading)
-   [객체지향 설계의 5원칙](#객체지향-설계의-5원칙)
-   [클래스와 인스턴스의 차이](#클래스와-인스턴스의-차이)
-   [Immutable](#immutable)
-   [디자인 패턴](#디자인-패턴)
-   [디자인 패턴 중 싱글톤 패턴](#디자인-패턴-중-싱글톤-패턴)
-   [디자인 패턴 중 MVC 패턴](#디자인-패턴-중-MVC-패턴)
-   [디자인 패턴 중 팩토리 패턴](#디자인-패턴-중-팩토리-패턴)
-   [MVC 패턴을 강화시키는 방법](#MVC-패턴을-강화시키는-방법)

# OS

## Table of Contents

-   [운영체제](#운영체제)
-   [프로세스 생성과정](#프로세스-생성과정)
-   [프로세스와 스레드의 차이](#프로세스와-스레드의-차이)
-   [멀티 프로세싱과 멀티 스레딩](#멀티-프로세싱과-멀티-스레딩)
-   [IPC](#ipc)
-   [Thread Safe와 Thread](#thread-safe와-thread)
-   [병렬성과 동시성의 차이](#병렬성과-동시성의-차이)
-   [Critical Section(공유 자원, 임계 영역)](#critical-section공유-자원-임계-영역)
-   [Race Condition](#race-condition)
-   [뮤텍스와 세마포어의 차이](#뮤텍스와-세마포어의-차이)
-   [Deadlock(교착상태)과 Deadlock 해결 방법](#deadlock교착상태과-deadlock-해결-방법)
-   [인터럽트](#인터럽트)
-   [PCB](#pcb)
-   [문맥 교환(Context Switching)](#문맥-교환context-switching)
-   [CPU 스케줄링 기법](#cpu-스케줄링-기법)
-   [메모리 구성](#메모리-구성)
-   [메모리 영역에서 힙과 스택의 차이](#메모리-영역에서-힙과-스택의-차이)
-   [스택 영역의 장점과 단점](#스택-영역의-장점과-단점)
-   [힙 영역의 장점과 단점](#힙-영역의-장점과-단점)
-   [가상 메모리와 가상 메모리 사용 시의 장점](#가상-메모리와-가상-메모리-사용-시의-장점)
-   [세그멘테이션](#세그멘테이션)
-   [페이징](#페이징)
-   [[참고] 페이지 테이블, TLB](#참고-페이지-테이블-tlb)
-   [페이지 교체 알고리즘](#페이지-교체-알고리즘)
-   [캐시의 지역성](#캐시의-지역성)
-   [컴퓨터가 부팅되는 과정](#컴퓨터가-부팅되는-과정)
-   [심볼릭 링크와 하드 링크의 차이](#심볼릭-링크와-하드-링크의-차이)
-   [컴파일러와 인터프리터의 차이](#컴파일러와-인터프리터의-차이)
-   [CPU와 GPU의 차이](#cpu와-gpu의-차이)
# Database

## Table of Contents
* [DBMS](#dbms)
* [DB를 사용하는 이유](#db를-사용하는-이유)
* [테이블](#테이블)
* [도메인](#도메인)
* [행](#행)
* [열](#열)
* [뷰](#뷰)
* [스키마와 테이블의 차이](#스키마와-테이블의-차이)
* [후보 키](#후보-키)
* [주 키](#주-키)
* [외래 키](#외래-키)
* [트랜잭션](#트랜잭션)
* [ACID](#acid)
* [무결성 제약조건](#무결성-제약조건)
* [조인](#조인)
* [시퀀스(오라클)](#시퀀스오라클)
* [트리거](#트리거)
* [SQL](#sql)
* [Commit과 Rollback](#commit과-rollback)
* [SQL Injection](#sql-injection)
* [힌트(Hint)](#힌트hint)
* [Index를 사용하는 이유와 장점 및 단점](#index를-사용하는-이유와-장점-및-단점)
* [Index 자료구조](#index-자료구조)
* [정규화](#정규화)
* [DB 클러스터링과 리플리케이션의 차이](#db-클러스터링과-리플리케이션의-차이)
* [커넥션 풀](#커넥션-풀)
* [관계형 데이터베이스(SQL)와 비관계형 데이터베이스(NoSQL)의 차이](#관계형-데이터베이스sql와-비관계형-데이터베이스nosql의-차이)
* [Redis와 MongoDB](#redis와-mongodb)
* [Redis의 데이터 휘발을 막기 위한 방법](#redis의-데이터-휘발을-막기-위한-방법)
* [PostgresSQL과 ElasticSearch의 차이점](#postgressql과-elasticsearch의-차이점)
* [[추가] NoSQL(Not Only SQL)](#추가-nosqlnot-only-sql)

## URL을 입력하고 벌어지는 일

* URL을 웹 브라우저의 주소창에 입력한다.
* 웹 브라우저가 URL을 해석하고, 문법에 맞지 않으면 기본 검색엔진으로 검색한다.
* 문법에 맞으면 URL의 호스트 부분을 인코딩한다.
* HSTS(HTTP Strict Transport Security) 목록을 확인하고 있으면 HTTPS로, 없으면 HTTP로 요청한다.
* DNS(Domain Name Server) 조회
  * 브라우저/로컬 캐시 확인해서 도메인에 해당하는 IP가 있는지 확인한다.
  * 없으면 OS에게 DNS 서버에 요청하라고 지시한다.
  * DNS 서버는 해당 도메인에 해당하는 IP를 돌려준다.
* TCP 소켓을 열고 3-way handshake로 연결을 설정한다.
* HTTPS 요청이라면 TLS(Transport Layer Security) handshake 과정을 통해 세션키를 생성한다.
* 세션이 유지되는 동안 서버에게 요청하고 응답을 받는 과정을 반복한다.
  * 응답 상태코드에 따라 다르게 처리한다.
  * 응답을 디코딩(Decoding)하고 캐싱 가능하다면 캐싱한다.
* 웹브라우저는 응답받은 HTML/CSS/JS 및 이미지,폰트 등의 리소스를 사용하여 렌더링 한다.
* 서버와의 세션이 종료되면 4-way handshake로 연결을 종료한다.


## DBMS
* 데이터베이스 관리 시스템(DataBase Management System)
* 응용 프로그램들이 데이터베이스를 공유하며 사용할 수 있는 환경을 제공
* 정의(DB의 사용 용도), 조작(수정, 삭제, 검색), 제어(수정, 접근 권한 부여)

## DB를 사용하는 이유
* 파일 시스템의 문제점을 해결하기 위해 사용
* 파일 시스템이 OS마다 다를 수 있기 때문에 OS에 종속적인 파일 시스템을 이용하는 것은 프로그램의 확장성을 해침
* 데이터 중복, 비일관성, 검색 등의 문제 존재 -> 중복 최소화, 보안성, 계속적 변화에 대한 적응
* DB는 `원자적 갱신`, `동시성 제어`, `데이터 보호`, `백업 및 회복` 등의 여러 데이터 관리 기능을 두어 데이터 관리를 편하게 하기 때문에 사용

## 테이블
* 행과 열로 이루어진 데이터의 집합

## 도메인
* 데이터베이스 필드에 채워질 수 있는 값들의 집합

## 행
* 테이블을 구성하는 데이터 셋으로 `튜플`이나 `레코드`라고 불림

## 열
* 테이블을 구성하는 데이터 셋으로 `속성`이라고 불림

## 뷰
* 특정 사용자로부터 특정 속성을 `숨기는` 기능으로 뷰를 정의하여 그 뷰를 테이블처럼 사용하게 하여 특정 속성을 숨김
* 메모리에 물리적으로 존재하지 않는 가상 테이블

## 스키마와 테이블의 차이
* `스키마는 테이블(릴레이션)의 이름과 속성들의 나열`로 테이블에서의 첫 행 헤더, 데이터의 구조와 구성을 설명
* `테이블은 행과 열로 구성된 데이터 집합`

## 후보 키
* 릴레이션을 구성하는 속성들 중에서 Tuple을 `유일하게 식별`할 수 있는 속성들의 부분 집합

## 주 키
* 후보 키 중에서 선택한 Main Key

## 외래 키
* 한 테이블의 키 중에서 다른 테이블의 튜플을 식별할 수 있는 키
* 참조되는 릴레이션의 `주 키`와 대응되어 릴레이션 간에 `참조 관계`를 표현하는 키
* 사용 이유: 테이블을 연결, 중복 방지
  * 예시: 물건 구매시 같은 사람이 여러 물건을 구매하면 사람에 대한 데이터가 중복 -> 사람과 물건 구매로 테이블을 분리해 중복 제거

## 트랜잭션
* 데이터베이스의 상태를 변화시킬 때 한 번에 수행되어야하는 하나의 `원자적인 작업의 단위`
* Lock과 유사한 기능을 하지만 Lock은 동일한 자원을 요청할 경우 한 시점에는 하나의 커넥션만 변경하는데에 반해 트랜잭션은 논리적인 작업의 쿼리의 개수와 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장

## ACID
* 데이터의 유효성을 보장하기 위한 트랜잭션의 특징
* `Atomicity(원자성)`: `모든 작업이 반영되거나 모두 롤백되는 특성`입니다.
* `Consistency(일관성)`: 데이터는 `미리 정의된 규칙에서만 수정이 가능한 특성`을 의미합니다.
* `Isolation(고립성)`: A와 B 두개의 트랜젝션이 실행되고 있을 때, A의 작업들이 B에게 보여지는 정도를 의미합니다.
* `Durability(영구성)`: 한번 반영(커밋)된 트랜젝션의 내용은 `영원히 적용`되는 특성을 의미합니다.

## 무결성 제약조건
* 개체 무결성: 주키는 null, 중복 값을 가질 수 없음
* 참조 무결성: 외래키는 null이거나 참조 릴레이션의 기본키 값과 동일해야 함

## 조인
* 두 개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법으로 적어도 하나의 칼럼을 서로 공유하고 있어야 함

## 시퀀스(오라클)
* 기본키와 같은 유일한 숫자를 자동으로 생성하는 것
* 캐쉬에 있어 속도 빠름, 중복 방지에 사용

## 트리거
* 자동으로 실행되게 정의한 프로시저
* DML(INSERT, UPDATE, DELETE)에 의한 데이터 상태관리 자동화
* 데이터 무결성 강화, 업무 처리 자동화

## SQL
* DML: 데이터를 조작
  |명령어|설명|
  |:---:|:---|
  |SELECT|DB의 데이터 조회 및 검색|
  |INSERT|데이터 삽입|
  |UPDATE|데이터 수정|
  |DELETE|데이터 삭제|
* DDL: 데이터(구조, 객체)를 정의
  |명령어|설명|
  |:---:|:---|
  |CREATE|DB의 테이블 생성|
  |DROP|테이블 삭제|
  |TRUNCATE|테이블의 데이터 삭제, 테이블 초기화|
  |ALTER|테이블 수정|
  * DROP과 TRUNCATE의 차이
* DCL: 데이터 제어
  |명령어|설명|
  |:---:|:---|
  |GRANT|객체에 대한 권한 부여|
  |REVOKE|객체에 대한 권한 회수|
  |COMMIT|트랜잭션의 결과 반영|
  |ROLLBACK|트랜잭션 취소 및 원상 복구|

## Commit과 Rollback
* Rollback: 트랜잭션의 실행을 취소하였음을 알리는 연산자로 `트랜잭션이 수행한 결과를 원래의 상태로 원상 복귀시키는 연산`

## SQL Injection
* 해커에 의해 조작된 SQL 쿼리문이 데이터베이스에 그대로 전달되어 비정상적인 명령을 실행시키는 공격 기법
* view를 활용하여 접근하는 에러를 볼 수 없게 하고 검증 로직을 추가하여 방어해야함
* 입력값 검증, Prepared Statement 사용(쿼리에 대한 컴파일을 먼저 수행하고, 입력값을 나중에 넣는 방식)

## 힌트(Hint)
* SQL을 튜닝하기 위한 지시 구문, 개발자가 직접 최적의 실행 계획을 제공하는 것

## Index를 사용하는 이유와 장점 및 단점
* 인덱스는 추가적인 쓰기와 저장 공간 사용을 통해 데이터베이스의 `검색 속도 향상`을 위해 사용하는 자료구조
* 테이블 내의 `칼럼의 값(Key)`과 해당 `Key의 레코드가 저장된 주소`를 `키와 값의 쌍으로 정의`
* 인덱스를 사용하면 검색이 빨리지지만 테이블의 데이터가 추가, 삭제, 수정이 자주되는 경우 인덱스도 변경해야 하여 성능이 오히려 저하될 수 있음

## Index 자료구조
* B 트리

  ![tree](https://user-images.githubusercontent.com/38900338/105454677-9bf88400-5cc5-11eb-993e-fb6f7b9675a1.png)
  * 이진 트리를 확장해서, 더 많은 수의 자식을 가질 수 있게 일반화 시킨 자료구조
  * 균형 트리: 루트 ~ 리프의 거리가 일정한 트리
  * Branch 노드: Key와 Data 저장
* B+ 트리

  ![Bplustree](https://user-images.githubusercontent.com/38900338/105454222-d9104680-5cc4-11eb-96e9-31e46c0bf2aa.png)
  * B 트리를 확장해서, 데이터의 빠른 접근을 위한 인덱스 역할만 하는 비단말 노드(not Leaf)가 추가시킨 자료구조
  * B 트리보다 풀 스캔 빠름
  * Leaf 노드를 제외하면 데이터를 저장하지 않아 더 많은 Key를 저장할 수 있음 -> 트리의 높이가 낮아져 Cache Hit 향상 가능
  * Branch 노드: Key만 저장, Leaf 노드: Key와 Data 저장 + Linked List로 연결(부등호를 사용한 순차 검색에 유용)
* 해시 테이블
  * 칼럼의 값으로 생성된 해시를 기반으로 인덱스 구현
  * O(1)로 매우 빠름
  * 인덱싱에선 부등호 연산 때문에 해시 테이블을 사용하면 성능이 떨어짐
  * `>=, Between, like, order by` 등은 불가능하지만 `==, in, is null` 등에서의 성능은 좋음

## 정규화
* 테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용하여 테이블을 `무손실 분해` 하는 과정
  * 무손실 분해: 하나의 릴레이션을 분해하고 다시 조인연산을 했을 때 데이터 손실이 없는 것
* 데이터 `중복 최소화`, `이상 현상` 제거
* 종류
  * 제 1 정규형: 모든 속성이 원자 값
  * 제 2 정규형: 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속(속성집합 Y 가 속성집합 X 전체에 대해서만 함수적으로 종속된 경우)
  * 제 3 정규형: 기본키가 아닌 모든 속성이 기본키에 비이행적 종속(직접 종속)
    * 이행적으로 함수 종속: X, Y, Z 에 대해 X->Y 이고 Y->Z 이면 X->Z
  * BCNF: 함수 종속성 X->Y일 때, 모든 결정자 X가 후보키

## DB 클러스터링과 리플리케이션의 차이
  ||DB 클러스터링|리플리케이션|
  |:---:|:----------:|:---------:|
  |대상|DB 서버를 다중화|DB 서버와 데이터를 같이 다중화|
  |구조|수평적 구조<br>(Fail Over)|수직적 구조<br>(Master-Slave)|
  |방식|동기 방식으로 동기화|비동기 방식으로 동기화|
  |종류|Active - Active, Active - Standby|단순 백업, 부하 분산|
  |장점|일관성,<br>1개의 서버가 고장나도 시스템은 계속 사용 가능|시간 지연 거의 없음|
  |단점|동기화 시간 소요|일관성 없음,<br>Master 오류시 복구 어려움|
  |구조|![clustering](https://user-images.githubusercontent.com/38900338/105463364-4b882300-5cd3-11eb-9837-195b872852e2.JPG)|![replication](https://user-images.githubusercontent.com/38900338/105463420-5f338980-5cd3-11eb-8ea4-fe1bdc962385.JPG)|

## 커넥션 풀
* 사용자의 요청에 따라 Connection 을 생성하다 보면 많은 수의 연결이 발생했을 때 서버에 과부하가 걸리게 되므로 이러한 상황을 방지하기 위해 `미리 일정 수의 Connection을 만들어 pool에 담아 뒀다가 사용자의 요청이 발생하면 연결을 해주고 연결 종료 시 pool에 다시 반환하여 보관하는 것`
* 커넥션 풀을 사용하면 커넥션을 생성하고 닫는 시간이 소모되지 않기 때문에 그만큼 어플리케이션의 실행 속도가 빨라짐
* 한 번에 생성될 수 있는 커넥션 수를 제어하기 때문에 동시 접속자 수가 몰려도 웹 어플리케이션이 쉽게 다운되지 않음

## 관계형 데이터베이스(SQL)와 비관계형 데이터베이스(NoSQL)의 차이
|관계형 데이터베이스|비관계형 데이터베이스|
|:----------:|:---------:|
|SQL 사용|다양한 질의어 사용|
|ACID|Eventual Consistency|
|엄격한 스키마 아래 행과 열로 구성된 `테이블`들의 관계로 데이터 저장|스키마가 없거나 느슨한 스키마로 데이터 저장|
|`속성(열)에 맞는 자료형에 따라` 데이터를 삽입|`key-value`, `Document` 구조의 유연한 데이터 삽입 구조를 갖음|
|관계를 맺고 있는 데이터가 자주 변경되거나 테이블 안에서 읽어올 데이터가 불분명한 경우 또는 명확한 스키마가 있는 경우|데이터 구조를 알 수 없거나 테이블 안에서 읽어올 데이터가 분명한 경우 또는 변경 확장이 쉽게 되어야하는 경우|
|데이터의 정렬, 탐색, 분류가 빠름<br>데이터 무결성 보장|대용량 데이터 처리에 효율적<br>관계형 DB보다 쓰기와 읽기 성능이 좋음<br>유연하고 확장성 좋음|
|기존의 스키마 수정 어려움, 빅데이터 처리에 비효율적|크기가 큰 Document에서는 성능 저하|
|`Oracle`, `MySQL`|키-값: `Redis`<br>문서형(JSON, XML): `MongoDB`|

## Redis와 MongoDB
* Redis는 No SQL 방식을 사용하는 인메모리 데이터베이스로 `Key-Value` 형식으로 데이터를 저장하며 주로 캐쉬로 사용
* MongoDB는 NO SQL 방식을 사용하는 데이터베이스로 JSON같은 구조의 `Document` 형식으로 데이터를 저장하고 문서에 대한 ID를 키로 표현

## Redis의 데이터 휘발을 막기 위한 방법
* `snapshot` 기능을 통해 디스크에 백업하거나 `AOF(Append Only File)` 기능을 통해 `명령 쿼리를 저장`해두고 서버가 셧다운 되면 재실행
* snapshot: 특정 시점의 백업 및 복구에 유리, 빠르게 복구 가능, 서버가 다운되면 스냅샷 사이에 변경된 데이터 유실
* AOF: 모든 write/update 연산 자체를 모두 log 파일로 기록, 서버가 실행되면 순차적으로 연산을 재실행하여 데이터를 복구, write 속도 빠름, 데이터 유실X, 데이터 사용량이 큼, 서버 restart 시 속도 느림

## PostgresSQL과 ElasticSearch의 차이점
* PostgresSQL은 관계형 데이터베이스이고 ElasticSearch는 검색 및 분석엔진
* ES는 데이터 모델을 JSON으로 하고 있어 NoSQL처럼 사용할 수 있음

## [추가] NoSQL(Not Only SQL)
* 관계형 데이터베이스가 아닌 다른 형태로 데이터를 저장하는 기술
* 특징
  * 반정형(명확한 스키마 없음, 일정 수준의 자유도 허용, NoSQL/JSON 형태의 데이터)/비정형(스키마 없음, 비디오/오디오 등의 멀티미디어 데이터) 데이터에 적합
  * ACID 대신 Eventual Consistency: Consistency를 조금 타협하고 꼭 실제 최신은 아닐 수 있지만 `업데이트가 되기 전까지는` 가지고 있는 최신의 데이터를 반환함을 의미 -> 분산형의 특성상 일관성 유지가 어려움
  * 대용량/분산형 데이터 저장에 유리
  * 특정 도메인의 문제 해결에 좋음: Key-value, Graph 등 자료 형태가 다양해 특정 분야에서 고성능(소셜 네트워크: 인간 관계는 그래프)
  * 데이터를 질의하는 API가 다양
  * 분산형 컴퓨터에 최적화, 확장성 좋음: 머신의 수를 늘리는 `수평적 확장`
  * NoSQL은 SQL보다 제품 지원이 어려움
  * 인력 운영 비용이 더 비쌈: 표준화 부족, 질의 언어 다양
* 종류
  * Column-based: 열 별로 연속적으로 저장, 기존 SQL은 테이블에 행 단위로 순차적으로 저장 -> 레코드의 특정 부분만 수정할 때, 필요한 열의 데이터만 로드하면 되서 IO 작업 감소, 한 열에 들어가는 데이터 형식에 일관성이 있어 DB 내의 한 블록은 동일한 유형의 데이터를 보유 -> 데이터의 유형에 맞는 압축 인코딩 가능, 디스크 공간 절약 및 성능 향상 가능
  * Document-oriented: JSON 객체로 문서(레코드)를 구성, 다양항 구조로 테이블 구성 가능, `MongoDB`
  * Key-Value: 연관 배열을 데이터 모델로 이용, Key는 한 Collection에 한 번만 등장 가능
  * Graph
## 운영체제

-   하드웨어를 관리하고, `응용 프로그램과 하드웨어 사이에서 인터페이스 역할`을 하는 시스템 소프트웨어

## 프로세스 생성과정

-   프로세스 관리 정보를 갖는 `Process Control Block를 생성`하고 프로그램의 코드를 읽어 들여 `코드 영역`을 메모리에 할당
-   초기화된 전역 변수 및 static 변수인 `데이터 영역`을 메모리에 할당
-   `힙과 스택의 초기 메모리 주소를 초기화`
-   `Queue에서 프로세스가 등록`되고 운영체제가 CPU를 할당하기를 대기

## 프로세스와 스레드의 차이

-   프로세스: `프로그램의 실행 상태`, 운영체제로부터 자원을 할당받아 실행, `코드/데이터/스택/힙` 메모리 영역
-   스레드: `프로세스의 독립적인 실행 단위`, `경량 프로세스`, 프로세스 안에서 프로세스로부터 자원을 받아 실행, 프로세스의 코드/데이터/힙 메모리 영역을 공유하고 `개별적인 스택`을 가짐

## 멀티 프로세싱과 멀티 스레딩

-   멀티 코어 환경은 공유 자원(Cirical Section)이 있을 시 동기화 매커니즘이 필요

| 멀티 프로세싱                                                                                                     | 멀티 스레딩                                                                                                                                                           |
| ----------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Pipe나 Shared Memory가 있어야 데이터를 주고 받을 수 있음                                                          | 스레드 간은 `Heap을 공유`하므로 Shared Memory가 없어도 Heap을 통해 데이터를 주고 받을 수 있음                                                                         |
| `많은 메모리 공간`을 차지<br>`IPC라는 별도 매커니즘`을 사용<br>프로세스 간의 통신 비용, 문맥 교환 `비용이 큼`<br> | `적은 메모리 공간`을 차지<br>프로세스를 생성하여 자원을 할당하는 시스템 콜이 감소함으로서 `자원을 효율적으로 관리`<br>스레드 간의 통신 비용과 문맥 교환 `비용이 적음` |
| 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행                                   | 하나의 스레드의 비정상적인 활동은 전체 스레드에 영향을 끼칠 수 있음                                                                                                   |

## IPC

-   Inter Process Communication
-   프로세스 간의 통신을 하는 것으로 Pipe, 공유 메모리, 소켓 등을 통해서 구현

## Thread Safe와 Thread

-   멀티 스레딩 프로그램에서 일반적인 변수나 객체, 함수에 여러 스레드가 동시에 접근해도 프로그램 실행의 문제가 없는 상태
-   Thread Safe한 코드: `Critical Session`을 통해 스레드 내부에서 처리되는 연산들을 `직렬화(Serialize)` 하여 한 번에 한 스레드에서 연산이 수행되도록 해야됨

## 병렬성과 동시성의 차이

-   병렬성: `멀티 코어`에서의 멀티 스레드, 각 코어들의 스레드가 동시에 실행
-   동시성: `싱글 코어`에서의 멀티 스레드, 여러 개의 스레드가 번갈아가며 실행

## Critical Section(공유 자원, 임계 영역)

-   접근 순서에 따라 실행 결과가 달라지는 구역

## Race Condition

-   공유 자원에 대한 여러 프로세스/스레드가 접근할 경우 `병렬 처리 상황에서 실행할 때마다 결과값이 다른 현상`

## 뮤텍스와 세마포어의 차이

-   둘 다 상호 배제를 달성하는 기법
-   뮤텍스는 `스레드 기반`으로 공유 자원의 활용을 제어하는 매커니즘, 바이너리 세마포어와 비슷한 방식으로 `동기화 대상이 1개`일 때 사용, 1개 스레드만 접근 가능
-   세마포어는 `프로세스 기반`으로 공유 자원의 활용을 제어하는 매커니즘, `동기화 대상이 여러 개`일 때 사용, `Deadlock`이 발생할 수 있음, 세마포어 변수만큼 프로세스 접근 가능
    -   wait(): 세마포어 변수 1감소 -> Critical Section -> signal(): 세마포어 변수 1증가

## Deadlock(교착상태)과 Deadlock 해결 방법

-   데드락이란 멀티 프로세스/스레딩 환경에서 잘못된 동기화 매커니즘 활용 때문에 프로세스/스레드가 `block`되어 `모든 프로세스/스레드의 작업이 끝나기만을 기다리는 현상`
-   상호 배제, 비선점, 점유와 대기, 원형 대기의 4가지 조건이 만족하면 발생
-   데드락 해결 방법: 모든 프로세스가 `lock을 잡는 순서를 동일`하게 코딩, `trylock`을 활용하여 lock을 선점한 프로세스/스레드가 없을 때만 락을 얻으려고 시도하는 방법

## 인터럽트

-   프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 `현재 실행 중인 작업을 즉시 중단`하고, `발생된 상황을 우선 처리`한 후 `실행 중이던 작업으로 복귀`하여 계속 처리하는 것
-   문맥 교환을 구현할 때 Timer Interrupt를 통해서 제어권을 커널이 가져올 수 있도록 활용

## PCB

-   Process Control Block
-   프로세스들의 관리를 위해 정보를 저장한 커널의 자료구조(Data 영역에 존재)
-   Process 상태, PC(다음에 수행할 명령어의 주소), CPU 레지스터, CPU 스케줄링 정보, 메모리 관리 정보 등을 저장

## 문맥 교환(Context Switching)

-   프로세스 사이에서 CPU 제어권이 이동되는 것
-   Context: CPU가 해당 프로세스를 실행하기 위한 해당 프로세스의 정보, 각 프로세스의 `PCB`에 저장
-   과정
    1. 실행 중이던 프로세스가 `자신의 프로세스의 상태(문맥)를 PCB에 보관`<br>
    2. 새로운 프로세스가 자신의 `PCB에서 문맥(Context)을 복원`<br>
    3. 새로운 프로세스 실행

## CPU 스케줄링 기법

-   SRT(Shortest Remaining Time): `남은 시간이 가장 적은` 프로세스를 실행
-   Round Robin: 시간 조각(Time Slice)라고 하는 단위로 공평하게 프로세스 실행
    -   할당된 시간 내에 끝나지 않으면 다음 프로세스에게 CPU를 양보하고 준비 상태 큐의 가장 뒤로 배치
-   MLFQ(Multi Level Feedback Queue): 우선 순위 개수만큼 Queue가 있으며 최상위 단계의 Queue부터 실행 후 해당 큐의 할당량이 끝나면 하위 우선 순위 Queue를 실행하는 스케줄링 기법으로 처음 시작은 모든 프로세스가 가장 높은 우선 순위 Queue에 존재하나 할당된 Time Slice를 소진하면 우선 순위를 감소시켜서 우선 순위를 정해가고 일정 주기마다 모든 작업을 가장 높은 우선 순위 큐로 이동시켜서 Starvation 방지(Aging)

## 메모리 구성

-   코드: 프로그램의 코드 저장
-   데이터: 전역 변수, 정적 변수 저장
-   스택: 지역 변수, 매개 변수, 함수의 호출과 할당, 컴파일에 크기 결정
-   힙: 동적으로 할당 및 해제, 런 타임에 크기 결정

## 메모리 영역에서 힙과 스택의 차이

-   힙: 프로그램 코드에서 `동적으로 할당`하여 사용될 때 할당되는 메모리 영역
-   스택: `함수를 호출`할 때나 `지역변수`를 지정할 때 `자동`으로 할당되는 메모리 영역

## 스택 영역의 장점과 단점

-   장점: 자동으로 처리되기 때문에 `낭비되는 공간이 없고` 사용하기가 편리
-   단점: 한계가 있어 한계를 초과하도록 삽입할 수 없고 `유연성이 부족`

## 힙 영역의 장점과 단점

-   장점: 프로그램에 필요한 개체의 개수나 크기를 미리 알 수 없는 경우 사용하고 개체가 너무 커서 스택 할당자에 맞지 않는 경우 사용 가능
-   단점: `할당/해제 작업`으로 인한 속도 저하

## 가상 메모리와 가상 메모리 사용 시의 장점

-   프로그램에 실제 메모리 주소가 아닌 `가상의 메모리 주소를 주는 방식`으로 프로그램 별로 사용 중인 메모리보다 큰 메모리를 사용하는 듯한 환상을 주는 기법
-   `MMU(Memory Management Unit)`는 가상 메모리 주소를 물리 주소로 변환
-   실제 프로그램 전체를 적재하여 사용하지 않고 일부분만 적재하기 때문에 메모리 제약을 극복
-   메모리의 실제 주소를 사용하지 않으므로 보안 상의 장점이 존재

## 세그멘테이션

-   메모리 영역인 커널 영역, 스택 영역, 공유 라이브러리 영역, 힙 영역, 데이터 영역, 코드 영역 등으로 메모리를 세그먼트로 나누고 `세그먼트 테이블`에 각 세그먼트의 시작 주소와 길이 정보를 운용하여 가상 메모리를 관리하는 기법

## 페이징

-   페이지: `가상 메모리`를 최소 단위로 쪼개어 만든 일정한 크기의 블럭
-   프레임: `물리 메모리`에 페이지 크기와 같은 블럭으로 나눈 블럭
-   프로세스를 일정 크기인 페이지로 잘라서 가상 메모리에 적재하고 페이지 테이블을 이용하여 프레임으로 변환하여 가상 메모리를 관리하는 기법
-   CPU가 가상 주소 접근 시 MMU가 페이지 테이블 base 주소를 접근해서 물리주소 가져 옴

## [참고] 페이지 테이블, TLB

-   MMU는 TLB라는 캐시를 저장하고 있다. 가상주소가 물리 주소로 변환되어야할 때, `TLB`에서 우선 검색된다.
-   해당 되는 주소가 있으면 (TLB hit) 물리주소가 리턴되고 메모리에 접근한다. 하지만, TLB에서 해당되는 주소가 없을 경우 (TLB miss) `page table`에서 맵핑이 존재하는지 찾는다. 존재할 경우에 (page table hit) 이 값은 다시 TLB에 쓰이고 그 주소를 이용해 물리 주소로 변환 후, 메모리에 접근한다.
-   page table에서도 찾지 못할 경우에는 `disk`에서 찾고, 그 값을 다시 page table과 TLB에 쓰고 물리주소로 변환 후 메모리에 접근한다.
-   요악: 가상 주소로 물리 주소에 접근할 때 `TLB -> page table -> disk` 순으로 접근한다.

## 페이지 교체 알고리즘

-   FIFO: 페이지 교체 시점에 들어온 페이지 순서대로 페이지를 교체하는 알고리즘으로 페이지 프레임의 개수를 늘리면 Page Fault 발생이 감소해야하나, 오히려 늘어나는 `Belady의 모순` 발생
-   LRU(Least-Recently-Used): 페이지 교체 시점에 `가장 오랫동안 사용되지 않은` 페이지를 선택하여 교체하는 알고리즘
-   LFU(Least-Frequently-Used): 페이지 교체 시점에 `참조 횟수가 가장 적은 페이지`를 교체하는 알고리즘

## 캐시의 지역성

-   시간 지역성: 최근에 참조된 주소의 내용은 곧 다음에 다시 참조되는 특성(순환, 재귀)
-   공간 지역성: 대부분의 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성(배열)

## 컴퓨터가 부팅되는 과정

-   처음에 부팅이 되면 `BIOS`가 실행 될 수 있도록 `메모리의 0번지에는 ROM`이 올라와있고, `CPU는 0번지를 읽어` 자동으로 ROM의 BIOS가 실행
-   `BIOS는 하드디스크의 0번지 부터 한 섹터를 읽어와 거기에 있는 부트스트랩 코드를 실행`시킨다. 부트스트랩이 `부트로더`(bootcamp, grub)를 실행시키고 그 다음 커널이 로드

## 심볼릭 링크와 하드 링크의 차이

-   심볼릭 링크(소프트 링크): 원본 파일의 이름을 가르키는 링크, 원본 파일이 사라지면 역할 수행X
-   하드 링크: 원본 파일의 이름을 가르키는 링크, 사본을 생성, 원본파일이 사라져도 원본과 동일한 내용의 파일을 가질 수 있음을 의미

## 컴파일러와 인터프리터의 차이

-   고급 언어로 작성된 프로그램 -> 기계어로 번역

|                                       컴파일러                                       |         인터프리터          |
| :----------------------------------------------------------------------------------: | :-------------------------: |
|                            프로그램 `전체`를 한 번에 번역                            |  프로그램을 `한 줄씩` 번역  |
| 목적 프로그램으로 번역 -> 링킹 -> 실행 가능한 실행파일(어셈블리, 바이너리 파일) 생성 | 번역과 동시에 프로그램 실행 |
|                                  목적 프로그램 생성                                  |     목적 프로그램 생성X     |
|                                    번역 속도 느림                                    |       번역 속도 빠름        |
|                                    실행 속도 빠름                                    |       실행 속도 느림        |
|                                       C, Java                                        |           Python            |

## CPU와 GPU의 차이

|                  CPU                  |                                       GPU                                       |
| :-----------------------------------: | :-----------------------------------------------------------------------------: |
| 컴퓨터의 자원을 관리하는 중앙처리장치 |                      반복적이고 비슷한 대량의 연산을 수행                       |
|  `직렬` 처리에 최적화된 몇 개의 코어  | `병렬` 처리용으로 설계된 수 천 개의 소형인 효율적인 코어로 구성<br>CPU보다 빠름 |

## 자바, C++, C, Python

-   자바: 컴파일 언어(코드 전체를 한번에 번역), 객체지향 언어, 기본 단위가 Class, 거의 완전한 OOP, 가상머신에서 실행하여 OS와 독립적, 가비지 콜렉션 지원
-   C++: 컴파일 언어, 객체지향 언어, C의 상위 호환으로 절차지향이 섞임, 각 OS에 맞는 기계어로 변환해 실행(속도 빠름), 메모리를 직접 관리할 수 있음
-   C: 컴파일 언어, 절차지향 언어
-   Python: 인터프리터 언어(코드를 한줄씩 번역해 실행), 객체지향 언어, C언어를 기반으로 한 언어로 머신러닝, 빅데이터 등의 분야에서 많이 사용

## 객체지향 프로그래밍과 장점

-   프로그래밍에서 필요한 데이터를 `추상화`시켜 상태와 행위를 가진 `객체`를 만들고 그 객체들 간의 유기적인 `상호작용`을 통해 로직을 구성하는 프로그래밍 방식
-   `추상화`가 쉽고 `상속`을 통해 코드 `재산성성`을 높일 수 있으며 객체 단위로 코드가 나눠져 있기 때문에 `디버깅과 유지보수`에 용이

## 객체지향과 절차지향

-   객체지향: 객체별 개별 코딩, 클래스를 이용해 기능별로 구성 가능, 실행 속도 느림, Java -> 상태 보관
-   절차지향: 해야 할 작업을 순서대로 코딩, 함수 단위로 구성, 실행 속도 빠름, C

## 객체

-   데이터(변수)와 데이터의 동작(함수, 절차, 기능)을 모두 포함한 개념

## Call by Value vs Call by Reference

-   `값을 복사`를 하여 처리하는지 `직접 참조`하는지의 차이
-   Call by Value: 인자로 받은 값을 복사하여 처리
-   Call by Reference: 인자로 받은 값의 주소를 참조하여 직접 값에 영향을 줌

## 객체지향 프로그래밍의 특징

-   `추상화`: 사물의 불필요한 부분을 제거하고 공통된 특징만 추출하여 이해하기 쉽게 만드는 작업
    -   하위클래스들에 존재하는 공통적인 메소드를 인터페이스로 정의
-   `캡슐화`: 속성과 기능을 멤버 변수와 멤버 함수로 만들어 클래스라는 캡슐에 넣음
    -   목적: 소스 코드의 수정없는 재활용
    -   외부 사용자는 클래스의 세부 구현에 대해 알 필요X
    -   `정보 은닉`: 접근지정자 `private`으로 멤버 변수 선언, 해당 변수에 접근하는 별도의 함수 정의
-   `상속`: 부모 클래스의 기능을 모두 또는 일부 수정하여 자식 클래스가 사용하는 것, 코드 재사용, 상속 받은 자식 클래스에서 일부 기능만 다시 수정(정의)하여 사용할 수 있게 하는 것
-   `다형성`: 같은 메서드가 각각의 객체에서 서로 다른 방법으로 응답, `상속`에서 효과를 발휘, 하나의 변수명/함수명 등이 상황에 따라서 다르게 동작하는 것
    -   부모 클래스: 추상 클래스, 함수: 추상 함수
    -   자식 클래스: draw 함수를 자신의 목적에 맞게, 서로 다른 방법으로 구현 / ex) 삼각형, 사각형 그리기

## Overriding과 Overloading

-   오버라이딩: 부모 클래스에 존재하는 메서드를 자식 클래스에서 재정의하는 것

```java
SuperClass super = new SubClass();
super.function(); // SubClass의 함수 실행
```

-   오버로딩: 같은 이름의 메소드를 여러 개 정의, 매개변수의 타입이나 개수가 달라야 함

## 객체지향 설계의 5원칙

-   `SRP(Single Responsibility Principle)`: 단일 책임 원칙, 클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.
-   `OCP(Open-Closed Principle)`: 개방-폐쇄 원칙, 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
    -   인터페이스
-   `LSP(Liskov Substitution Principle)`: 리스코프 치환 원칙, 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
    -   자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있다는 원칙이다
    -   자식 클래스가 부모 클래스의 기존 메소드의 의미를 해치지는 않는다.
-   `ISP(Interface Segregation Principle)`: 인터페이스 분리 원칙, 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
    -   자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원칙
    -   일반적인 한 개의 인터페이스보다 구체적인 여러가지의 인터페이스를 구현하는 원칙
-   `DIP(Dependency Inversion Principle)`: 의존 역전 원칙, 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.
    -   변하지 않는 객체에 의존한다.
    -   상위 클래스, 인터페이스, 추상 클래스일수록 변하지 않을 가능성이 높기에 하위 클래스나 구체(concrete) 클래스가 아닌 상위 클래스, 인터페이스, 추상 클래스에 의존한다.

## 클래스와 인스턴스의 차이

-   클래스는 객체를 만들기 위한 템플릿, 객체는 클래스라는 템플릿을 토대로 `메모리에 할당한 실체`
-   클래스: `객체를 만드는 틀`, 객체의 속성과 기능(행위)을 정의
-   객체: `클래스라는 틀에서 생겨난 실체`, 속성(멤버 변수)과 기능(메소드, 함수)의 집합

## Immutable

-   생성 후 변경 불가한 객체로 변경을 하려면 복사 이후 변경해야함

## 디자인 패턴

-   소프트웨어 코드 작성 시에 생기는 `공통적인 문제를 해결하는데 도움이 되는 코드 패턴`

## 디자인 패턴 중 싱글톤 패턴

-   전체 프로그램에서 `단 1개의 객체`를 생생하고 공유하는 코드 패턴
-   한번의 객체 생성으로 `재사용`이 가능하기 때문에 메모리 낭비를 방지하고 객체가 `전역성`을 띄기 때문에 공유가 용이

## 디자인 패턴 중 MVC 패턴

-   Model, View, Controller라고 하는 컴포넌트로 분리하여 `비지니스 처리 로직`과 사용자 `인터페이스 요소`를 분리시켜 서로 영향없이 개발하기 수월

## 디자인 패턴 중 팩토리 패턴

-   팩토리 패턴은 클래스의 `인스턴스를 만드는 것을 서브클래스에서 결정하는 패턴`으로 팩토리 메서드 패턴과 추상 팩토리 패턴으로 구체화됨
-   팩토리 메서드 패턴: 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 `서브클래스`에서 결정
-   추상 팩토리 패턴: 인터페이스를 이용하여 서로 연관된, 또는 의존하는 객체를 구상 클래스를 지정하지 않고도 생성

## MVC 패턴을 강화시키는 방법

-

## TCP와 UDP의 차이

-   TCP는 `신뢰성을 보장하는 연결형 프로토콜`로 `흐름제어, 혼잡제어`를 제공
-   UDP는 `신뢰성을 보장하지 않는 비연결형 프로토콜`로 흐름제어, 혼잡제어를 제공하지 않음

## TCP 흐름제어

-   수신자와 송신자의 메시지 처리속도 차이를 해결하기 위한 방법
-   수신자와 송신자 세그먼트 간의 TCP Header에 `remain window data`를 통해 남은 버퍼를 알고 흐름을 파악할 수 있음

### 종류

-   `Stop and Wait`: 전송한 패킷의 ACK을 수신하면 다음 패킷 전송
-   `Sliding Window`: N개의 패킷을 ACK의 확인 없이 전송, 데이터의 흐름을 동적으로 조절
    -   `Go Back N`: Cumulative ACK(마지막으로 수신 성공한 패킷의 ACK을 계속 전송), 문제가 된 패킷부터 모두 재전송
    -   `Selective Repeat`: Individual ACK(수신 성공한 패킷의 개별 ACK 전송), 문제가 된 패킷만 재전송

## TCP 혼잡제어

-   송신자와 네트워크(라우터)의 데이터 처리 속도 차이를 해결하기 위한 방법
-   패킷 loss 시의 확인되는 `timeout이나 3개의 duplicate ACK`을 통해서 파악 가능

### 종류

-   [참고] CWND: Congestion Window, ACK을 확인하지 않고도 보낼 수 있는 데이터 양
-   `TCP Tahoe`
    -   Slow Start(CWND가 1부터 지수적으로, 2배씩 증가) -> ssthresh -> Congestion Avoidance(CWND가 1씩 증가) -> 3개의 duplicate ACK, Timeout 발생 -> Slow Start부터 반복
-   `TCP Reno`
    -   Slow Start(CWND가 1부터 지수적으로, 2배씩 증가) -> ssthresh -> Congestion Avoidance(CWND가 1씩 증가)까지는 동일
    -   Congestion Avoidance 상황에서 3개의 duplicate ACK 발생 -> CWND를 1/2배로 감소하고 선형적 증가
        (TCP Tahoe는 Slow Start로 진입)
    -   Congestion Avoidance 상황에서 Timeout 발생 -> Slow Start (CWND = 1, CWND가 1부터 2배씩 증가)

## TCP 3-way handshake가 언제 일어나고 어떤 과정인지

-   서버와 클라이언트가 TCP `연결을 성립할 때` 사용
-   Client -> Server: `SYN 전송`
-   Server -> Client: `SYN 전송 + ACK 전송`
-   Client -> Server: `ACK 전송`
-   TCP는 양방향성 연결이기 때문에 발생하는 매커니즘으로 연결을 성립할 때는 서버가 준비가 다 된 상태인 대기 상태에서 시작하여 3-way로 가능
-   TCP는 양방향 프로토콜이므로 클라이언트와 서버가 각각 서로에게 패킷을 전송할 수 있다는 것을 확인해야 되므로 3 way 사용

## TCP 4-way handshake가 언제 일어나고 어떤 과정인지

-   서버와 클라이언트가 TCP `연결을 종료할 때` 사용
-   Client -> Server : `FIN 전송`
-   Server -> Client : `ACK 전송`
-   Server -> Client : `FIN 전송`
-   Client -> Server : `ACK 전송`
-   서버의 지연된 패킷을 수신하기 위해 클라이언트에 Timeout 존재
-   TCP는 양방향성 연결이기 때문에 발생하는 매커니즘으로 연결 해제할 때는 한 쪽이 준비가 되지 않은 상태이기 때문에 연결 해제 대기 상태로 만들기 위해서 4-way로 해야 가능
-   클라이언트가 일방적으로 끊으면 서버는 '연결은 되어 있으나 요청이 없는 상태'로 오해할 수 있어 4 way 사용
-   클라이언트는 데이터 전송을 끝냈다고 하더라도 서버는 전송할 것이 남아있을 수 있어 4 way 사용

## OSI 7계층과 각 계층의 역할

### (1) 정의

-   네트워크의 통신 과정을 7단계로 나눈 것

### (2) 사용 이유

-   이해하기 쉬움, 문제 발생시 해당 단계의 장비와 SW만 수정하면 됨

### (3) 종류

-   Application - Application(7), Presentation(6), Session(5) 계층으로 분리
-   Application(7, Data): 사용자에게 `실제 애플리케이션 서비스`를 제공하는 계층 / HTTP
-   Presentation(6, Data): 애플리케이션의 `데이터 형태와 구조를 변환(번역, 암호화, 압축)`시키는 계층
-   Session(5, Data): 애플리케이션 간의 `TCP/IP 세션을 구축하고 관리하며 종료`시키는 계층
-   Transport(4, Segment): 통신 `양단 간의 신뢰성 있는 통신`을 보장하는 계층 / TCP or UDP
-   Network(3, Packet or Datagram): 목적지까지의 경로를 선택하고 `경로에 따라 패킷을 전달(라우팅)`해주는 계층 / IP
-   Link(2, Frame): 인접한 `피어 간의 신뢰성 있는 통신`을 보장하는 계층 / MAC
-   Physical(1, Bit): 전기적, 기계적, 기능적인 특성을 이용해서 통신 케이블로 데이터를 전송

## CDN과 사용 시의 이점

-   Contents Delivery Network
-   `지리적, 물리적으로 떨어져 있는 사용자에게 웹 페이지 콘텐츠 로드 지연을 최소화하는, 촘촘히 분산된 서버로 이루어진 플랫폼 기술`
-   웹 브라우저를 실행하는 디바이스인 사용자 에이전트는 HTML, 이미지, CSS, JavaScript 파일을 렌더링하는데 필요한 콘텐츠를 요청하고 요청된 서버에 의해 `콘텐츠에 대한 각 요청이 발생하면 최적으로 배치된 CDN 서버에 엔드유저가 매핑`되고, 해당 서버는 요청된 파일의 캐싱된(사전 저장된) 버전으로 응답하여 CDN 서버에게서 데이터를 전송받도록함

## 로드 밸런싱

-   로드 밸런서를 클라이언트와 서버 사이에 두고, 부하가 일어나지 않도록 여러 서버에 분산하는 방식
-   로드 밸런서는 물리 장비를 이중화해서 구현하거나 nginx(엔진X)와 같은 웹서버를 이용하여 구현

## CIDR

-   클래스 없는 도메인 간 라우팅 기법
-   최신의 IP 주소 할당 방법으로 정적이였던 클래스 방식에 비해 IP 주소의 영역을 여러 네트워크 영역으로 나눌 수 있기 때문에 기존방식에 비해 유연

## HTTP 특징

-   Connectionless: 클라이언트에서 서버에 요청을 보내면 서버는 클라이언트에 응답을 하고 접속을 끊음
-   Stateless: HTTP 통신은 요청을 응답하고 접속을 끊기 때문에 클라이언트의 상태정보를 저장하지 않음

## HTTP 1, 2, 3의 차이 \*

-   HTTP 1.1: 연결 당 하나의 요청과 응답을 처리 -> 동시 전송 문제, 속도 성능 이슈가 있음
    -   HOL(Head of Line) Blocking: 먼저 받은 요청이 끝나지 않으면 그 뒤에 있는 요청도 처리 불가
    -   RTT(Round Trip TIme) 증가
    -   헤더가 큼: 쿠키가 큼
-   HTTP 2: 한 연결에 여러 메시지를 동시에 처리 가능, 헤더 압축(HPACK), TCP에서 동작, 스트림
-   HTTP 3: 헤더 압축(QPACK), UDP에서 동작

## HTTP 상태코드

-   2xx: 성공
-   3xx: 리다이렉션
    -   301(Moved Permanently): 요청한 자원의 URL이 변경됨, 새로운 URL이 응답에 있을 수도 있음
    -   302(Found): 요청한 자원의 URL이 일시적으로 변경됨, 새롭게 변경된 URL이 나중에 만들어질 수도 있어 클라이언트는 동일한 URI로 요청해야 함
-   4xx: 클라이언트 에러
    -   401(Unauthorized): 클라이언트는 요청에 대한 응답을 받기위해 인증이 필요
    -   403(Forbidden): 클라이언트는 자원에 접근할 권리가 없음, 401과 다르게 서버가 클라이언트가 누구인지 알 고 있음
-   5xx: 서버 에러

## HTTP와 HTTPS(HTTP Secure)의 차이

|      |                                                 HTTP                                                  |                                                                      HTTPS                                                                      |
| :--: | :---------------------------------------------------------------------------------------------------: | :---------------------------------------------------------------------------------------------------------------------------------------------: |
| 정의 |                            웹 브라우저와 웹 서버가 통신하기 위한 프로토콜                             |                                              HTTP에 SSL/TLS 기반의 Secure Socket을 활용한 프로토콜                                              |
| 보안 | 평문 통신이기 때문에 `도청`이 가능하고 `변조`가 가능<br>통신 상대를 특정하지 않기 때문에`위장`이 가능 | 웹 브라우저와 웹 서버가 각각 키를 가지며<br>`그 키를 통해 암호화/복호화하여 HTTP통신`을 하기 때문에<br>클라이언트와 서버만이 데이터를 열람 가능 |

## 대칭키 암호화

-   하나의 키로 암/복호화를 모두 하는 방식

## 비대칭키(공개키) 암호화

-   두 개의 키로 암/복호화를 하는 방식
-   A, B 키 -> A키로 암호화하고 B키로 복호화 또는 B키로 암호화하고 A키로 복호화
-   비공개키(개인키)는 자신만이 소유하고 공개키는 타인에게 제공하는 방식으로 작동

## 인증기관(Certification Authority, CA)

-   인증기관으로부터 공인인증서를 발급받아 서버에 설치해야 HTTPS 통신 가능
-   웹 서비스 제공자는 자신의 공개키와 개인키를 생성, 공개키를 인증기관에 보냄
-   인증기관은 공개키, 유효기간 등 정보를 포함하여 인증기관의 개인키로 전자서명한 인증서를 발급
-   웹 서버는 인증서와 개인키를 가지게 되어 HTTPS 통신을 할 수 있게 됨
-   클라이언트에는 여러 인증기관의 공개키와 인증서가 이미 설치되어 있음
-   웹 서버와 통신 시, 인증기관의 `개인키`로 서명된 인증서를 클라이언트가 받으면 인증기관의 `공개키`로 복호화 가능

## SSL(Secure Sockets Layer) 동작방식

-   SSL을 사용하면 `https://` 를 사용하여 웹서버에 접근
-   대칭키: 실제 데이터 암호화 방식
-   공개키: 대칭키를 공유하기 위해 사용

1. 웹 브라우저가 웹 서버에 접속<br>
2. 웹 서버는 인증서를 웹 브라우저에게 전송 -> 인증서: 인증기관의 개인키로 암호화된 `사이트의 정보`와 `공개키`가 있음<br>
3. 웹 브라우저는 이미 가지고 있는 인증기관의 `공개키`로 웹 서버에서 받은 인증서를 `복호화` 해서 확인<br>
4. 웹 브라우저는 실제 데이터의 암호화에 사용될 `대칭키`를 생성, 인증서에서 꺼낸 웹 서버의 `공개키`로 `암호화` 해서 웹 서버로 전송<br>
5. 웹서버는 자신이 가지고 있는 `개인키`로 웹 브라우저가 보내온 `대칭키`를 `복호화` 해서 얻음<br>
6. 해당 대칭키로 데이터를 암호화해서 주고 받음

## TLS(Transport Layer Security) 동작방식 \*

## HSTS(HTTP Strict Transport Security)

-   Web Site에 접속할 때, 강제적으로 `HTTPS Protocol`로만 접속하게 하는 기능
-   일정시간 (max-age) 동안 HSTS 응답을 받은 웹사이트에 대해서 https 접속을 강제화
-   브라우저는 HTTPS를 사용해야 하는 웹 사이트의 목록을 만들고 이것을 사용

### 사용 목적

-   SSL Stripping 공격(중간자 공격)을 방지하기 위해 사용
-   사용자가 HTTPS를 지원하는 사이트에 HTTP로 접속 했을 때, 중간자 공격에 의해 HTTP 통신을 하게 되어 공격자에게 정보가 노출되는 것을 방지

## 쿠키와 세션

-   HTTP 통신에서 Connectionless, Stateless 보완

### (1) 쿠키

-   `클라이언트의 로컬(브라우저)`에 저장되는 `키와 값`이 들어있는 작은 텍스트 데이터 파일
-   이름, 값, 만료 날짜/시간, 경로 정보 등 저장
-   예시: 자동 로그인, 쇼핑몰의 장바구니, 아이디와 비밀번호 저장

### (2) 쿠키의 동작 과정

1. 클라이언트가 서버에 요청<br>
2. 서버는 `HTTP 응답 헤더`에 `set-cookie` 속성을 추가하여 응답 -> 클라이언트는 쿠키 저장<br>
3. 클라이언트는 이후 서버에 요청할 때 전달받은 쿠키를 자동으로 요청헤더에 추가하여 요청(브라우저가 자동으로 추가)<br>
4. 서버에서 쿠키를 참고하여 로직 수행<br>

### (3) 세션

-   일정 시간동안 같은 브라우저에서 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 객체로 `서버`에 저장하는 기술
-   예시: 로그인

### (4) 세션의 동작 과정

1. 클라이언트가 서버에 요청<br>
2. 서버는 세션에 클라이언트에 대한 데이터를 저장하고 `HTTP 응답 헤더`에 `sessionid`를 추가하여 응답<br>
3. 클라이언트는 이후 서버에 요청할 때 전달받은 세션 쿠키를 자동으로 요청헤더에 추가하여 요청<br>
4. 서버에서 `sessionid`를 참고하여 로직 수행<br>

### (5) 차이점

|            |                                 쿠키                                 |                           세션                            |
| :--------: | :------------------------------------------------------------------: | :-------------------------------------------------------: |
| 저장 위치  |                클라이언트 `로컬`에 `작은` 파일로 저장                |             `서버`에 `제한 없는` 파일로 저장              |
|    보안    | 파일로 저장해 탈취와 변조 가능<br> 응답/요청 시에 스니핑 위험이 있음 | `sessionid`를 통해 데이터를 구분하여 처리하여 보안이 좋음 |
| Life Cycle |                   브라우저를 종료해도 파일로 남음                    |                브라우저 종료 시, 세션 삭제                |
|    속도    |                          파일에서 읽어 빠름                          |               요청마다 서버에서 처리해 느림               |

## 캐시

-   이미지나 css, js파일 등을 브라우저나 서버 앞 단에 저장해놓고 사용하는 것
-   같은 자원을 로드(load)해야할 때, 해당 자원을 다시 불러오지 않고 캐시되어 있는 자원을 써서 클라이언트 자원을 절약
-   캐시에 있는 것을 재사용하기 때문에 경우에 따라 변경된 자원을 참조할 수 없는 경우가 생김

## JWT \*

-   JSON Web Token
-   `Json` 포맷을 이용하여 사용자에 대한 속성을 저장하는 Claim 기반의 Web Token
-   Header, Payload, Signature로 구성
-   세션은 사용자의 수 만큼 서버 메모리를 차지하기 때문에, 최근에는 세션의 문제를 보완한 토큰 기반의 인증방식을 사용하는 추세

## 웹 서버와 웹 애플리케이션 서버의 차이점

-   웹 서버: Http 프로토콜을 기반으로, 클라이언트의 요청을 처리하는 서버로 `정적 컨텐츠`만 처리하는 고성능 서버
-   웹 애플리케이션 서버: 보통 웹서버 뒤에서 DB 조회 및 다양한 로직 처리 요구 시, `동적 컨텐츠`를 처리하는 서버

## 웹 브라우저에 URL을 입력했을 때의 수행 과정

-   사용자의 PC는 `DHCP 서버`에서 사용자 `자신의 IP 주소`, `가장 가까운 라우터의 IP 주소`, `가장 가까운 DNS서버의 IP 주소`를 받는다.
-   `ARP`를 이용하여 IP 주소를 기반으로 가장 가까운 라우터의 MAC 주소를 받는다.
-   가장 가까운 라우터의 MAC 주소와 IP 주소를 사용해 DNS 서버로 쿼리를 전송하고 URL의 IP 주소를 응답받는다.
-   TCP Socket을 통해 웹 서버와 `3 way hand shaking`을 하여 연결한다.
-   `HTTP Request`가 TCP Socket을 통해 보내지고, 응답으로 웹페이지의 정보가 사용자의 PC에 전달

## 기타 네트워크 프로토콜과 기본 네트워크 주소들

-   DHCP: 호스트의 IP 주소 및 TCP/IP 설정을 클라이언트에 자동으로 제공하는 프로토콜
-   DNS: IP 주소와 도메인의 매핑 정보를 관리하는 프로토콜
-   ARP: IP 주소를 물리적 네트워크 주소로 대응시키기 위해 사용되는 프로토콜
-   IP 주소: 컴퓨터 마다 부여된 고유의 주소
-   MAC 주소: NIC 카드 마다 부여된 네트워크 장비 고유의 주소

## 웹 캐시

-   대부분의 브라우저에서는 `HTTP 헤더`에 캐시 구현이 포함되어 있어서 웹 캐시를 구현
-   응답 헤더의 `Last-Modified`, Etag, Expires, Cache-Control 항목 등과 같은 여러 부분의 여러 개의 태그를 통해서 캐싱
-   `Cache-Control`: HTTP 헤더를 통해 캐싱 정책을 정의할 수 있다. `no-cache` vs `no-store`
-   브라우저는 최초 응답 시 받은 `Last-Modified` 값을 If-Modified-Since라는 헤더에 포함 시켜 페이지를 요청 ->서버는 요청 파일의 수정 시간을 If-Modified-Since값과 비교하여 동일하다면 304 Not Modified로 응답하고 다르다면200 OK -> 브라우저는 응답 코드가 304인 경우 캐쉬에서 페이지를 로드하고 200이라면 새로 다운받은 후 Last-Modified값을 갱신
-   브라우저는 최초 응답 시 받은 `Etag` 값을 If-None-Match라는 헤더에 포함 시켜 페이지를 요청 -> 서버는 요청 파일의 Etag 값을 If-None-Match 값과 비교하여 동일하다면 304 Not Modified로 응답하고 다르다면 200 OK와 함께 새로운 Etag값을 응답 헤더에 전송 -> 브라우저는 응답 코드가 304인 경우 캐쉬에서 페이지를 로드하고 200이라면 새로 다운받은 후 Etag값을 갱신
-   브라우저는 최초 응답 시 받은 `Expires` 시간을 비교하여 기간 내라면 서버를 거치지 않고 바로 캐쉬에서 페이지를 로드

## URI, URL, URN

### (1) URI(Uniform Resource Identifier)

-   자원을 고유하게 식별하고 위치를 지정하는 통합 자원 식별자
-   URL, URN 두 가지 형태 존재
-   인터넷 프로토콜을 명시함
-   예시: http://www.naver.com

### (2) URL(Uniform Resource Location)

-   특정 서버의 한 리소스에 대한 구체적인 위치
-   자원의 위치와 접근 방법을 분명히 알려줌
-   예시: http://test.com/test/test.pdf 는 test.com서버에서 test폴더안의 test.pdf 파일을 요청

### (3) URN(Uniform Resource Name)

-   자원의 위치와 독립적인 이름
-   URL이 변경되면 기존의 객체를 찾을 수 없다는 URL의 한계를 극복하기 위해 사용
-   예시: urn:2.19.222

## REST

-   자원을 이름으로 구분하여 자원의 상태를 주고 받는 것
-   `HTTP, WWW에서 웹에 존재하는 모든 자원에 고유한 URI를 부여`해 활용하는 것으로, 자원을 정의하고 자원에 대한 주소를 지정하는 방법론
-   `HTTP URI`를 통해 자원을 명시하고 `HTTP Method(POST, GET, PUT, DELETE)`를 통해 해당 자원에 대한 `CRUD` 연산을 적용

## REST API

-   `REST API`는 `REST 기반의 규칙들을 지켜서 설계된 API`
-   기본 설계 원칙1. `/`를 계층관계를 나타내는데 사용하되 마지막 문자에 `/`를 포함하지 않음
-   기본 설계 원칙2. 자원에 대한 정보는 명사로 표현하고 자원에 대한 `행위는 HTTP 메소드`로 표현
-   기본 설계 원칙3. 소문자와 `-(하이픈)`를 사용
-   기본 설계 원칙4. 브라우저는 form-data 형식의 submit 으로 보내고 서버에서는 json 형태로 보내는 식의 분리보다는 둘 다 form-data 형식으로 보내든 하나로 통일

## REST API 장단점

-   HTTP를 사용하므로 웹 인프라를 그대로 이용할 수 있고 MSA에 적합하여 재사용에서 이점이 존재
-   HTTP를 사용하므로 HTTP 통신 모델에 제약적

## RESTful

-   REST 원리를 따르는 시스템을 나타내기 위해 사용하는 용어
-   RESTful한 API를 구현하는 목적은 성능 향상이 아니라 일관적인 컨벤션을 통한 API의 이해도 및 호환성을 높이는 것

## HTTP GET 방식과 POST 방식의 차이

-   `GET은 정보를 조회하기 위한 메소드`이고 `POST는 서버로 데이터를 전송하기 위해 설계된 메소드`
-   둘다 데이터를 서버에 전달할 수 있다는 것이 공통점이지만 GET은 `URL의 파라미터`로 이름과 데이터가 쌍으로 명시되어 전달되고, POST는 `HTTP Request Message의 Body` 부분에 데이터가 담겨있음
-   GET은 `URL의 길이는 제한적이기` 때문에 많은 양의 데이터를 전송할 수 없지만 POST는 `HTTP RequestMessage의 Body`에 데이터가 담겨있어 제한이 없음

## HTTP POST 방식과 PUT 방식의 차이

-   일반적으로 POST는 생성, PUT은 수정이지만 PUT으로도 생성이 가능
-   POST와 가장 큰차이는 PUT 메서드는 자원의 식별자를 이미 알고있는 상태로 POST는 request message에 포함된 엔티티를 이용해 새로운 자원을 생성해 내는 것이고, PUT은 request message와 함께 넘어온 식별자의 자원을 만드는 것
-   Post: 멱등X, Put: 멱등

## HTTP 멱등성

-   같은 요청을 반복하는 경우, 모든 요청에 따른 서버의 상태가 같아야 함
-   안전한 메소드(GET, 서버의 상태 변경X)는 서버의 상태를 변경시키지 않음
-   멱등한 메소드(PUT, DELETE, GET)는 서버의 상태를 변경시킬 수도 있고 아닐 수도 있음
-   POST는 멱등이 아니면서 안전하지도 않음

## 웹 브라우저에 HTTP 응답이 랜더링되는 과정 \*

-

## 배열과 리스트 비교

### (1) 배열

-   순차적으로 데이터를 저장하는 자료구조로 `메모리 상에 연속적으로 할당한` 자료구조
-   조회 성능이 좋고, 삽입/삭제 성능은 나쁨
-   선언 시 지정한 크기 변경 불가

### (2) 리스트

-   메모리가 연속적인 공간에 있지 않고 다음 노드를 가리키는 주소값을 가져 주소를 통해 접근
-   조회 성능이 나쁘고, 삽입/삭제 성능은 좋음
-   크기가 고정적이지 않음

## 배열과 링크드 리스트 비교

### (1) 배열

-   순차적으로 데이터를 저장하는 자료구조로 `메모리 상에 연속적으로 할당한` 자료구조
-   배열은 순서를 알고 있다면 `탐색에서 O(1)`, `삽입 삭제에서 O(N)`

### (2) 링크드 리스트

-   `따로 할당하고 이은` 자료구조, 자료의 주소값으로 서로 연결
-   링크드 리스트는 `탐색에서 O(N)` 순서를 알고 있다면 `삽입 삭제에서 O(1)`

## 배열 리스트와 링크드 리스트 비교

### (1) 배열 리스트

-   내부적으로는 배열을 활용하기 때문에 `탐색에서 O(1)`, `삽입 삭제에서 O(N)`
-   원하는 데이터에 무작위 접근 가능
-   리스트의 크기에는 제한이 있어 크기 재조정에는 많은 연산 필요
-   데이터의 추가/삭제에는 임시 배열을 생성하여 복제해 시간이 오래 걸림
-   캐시의 특성 때문에 빈번한 삽입 삭제가 나지 않는 경우라면 배열 리스트를 사용할 때 일반 적으로 성능이 더 좋음

### (2) 링크드 리스트

-   `탐색에서 O(N)` 순서를 알고 있다면 `삽입 삭제에서 O(1)`
-   무작위 접근은 불가능, 순차 접근만 가능
-   리스트의 크기에 영향 없이 데이터 추가 가능
-   데이터 추가에는 새로운 노드를 생성해 연결하므로 추가/삭제 연산이 빠름

## 해시 테이블

-   Key와 Value로 데이터를 저장하는 자료구조
-   배열과 리스트의 장점을 합친 자료구조로 `key 값`을 통해 해시 주소를 알아내어 평균적으로 `탐색에 있어 O(1)`을 보장하는 자료구조
-   해시 충돌이 발생할 경우, 같은 해시값에 대해 데이터들을 조회해 원하는 값을 찾기 때문에 `O(N)` 가능
-   `해시 충돌`(서로 다른 key가 같은 hash로 변경되는 문제)이 나는 경우 그 다음 비어 있는 공간에 삽입하는 방식인 `선형 조사법` 또는 해시 주소로 관리되는 데이터를 연결 리스트로 관리하는 방식인 `체이닝 기법`을 통해서 해결

## Stack과 Queue

### (1) Stack

-   LIFO 방식으로 삽입되고 제거되는 최근성에 포커싱된 자료구조
-   Array로 구현하는 것이 좋음

### (2) Queue

-   FIFO 방식으로 삽입되고 제거되는 순차성에 포커싱된 자료구조
-   Linked List로 구현하는 것이 좋음

## Tree

-   트리는 `사이클을 가지지 않는 그래프`로 부모 자식 관계를 갖는 노드들의 집합으로 `계층적` 구조를 갖는 자료구조
-   `이진 트리(Binary Tree)`: 최대 2개의 자식 노드들만 가질 수 있는 트리
-   `포화 이진 트리(Full Binary Tree)`: 각 레벨에 노드가 꽉 차있는 트리
-   `완전 이진 트리(Complete Binary Tree)`: 높이가 K인 트리에서 레벨 1~ 레벨 K-1까지 모두 채워져 있고 마지막 레벨에서는 왼쪽부터 순서대로 채워져 있는 트리
-   `이진 탐색 트리(Binary Search Tree)`: 탐색을 위해 만들어진 자료구조로 `부모 노드의 키 값이 왼쪽 자식 노드의 키값보다 크고 오른쪽 자식 노드의 키값보다 작은 구조`

## 힙

-   힙은 `완전 이진 트리`의 일종으로 `우선 순위 큐`를 구현하기 위해 만들어진 자료구조인데 이진 탐색 트리가 전체 노드를 탐색하기 위한 자료구조라면 힙은 `최소값 또는 최대값`을 쉽게 뽑아내기 위한 자료구조
-   `부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰/작은 완전 이진 트리`로 힙은 자식 노드에도 구분 조건이 필요한 이진 탐색 트리보다 느슨한 정렬 상태를 유지

## Binary Search Tree의 최악의 시간복잡도와 최악의 시간복잡도를 유발하는 케이스

-   밸런싱이 된 BST는 `O(logN)`이지만 밸런싱이 되지 않지 않고 `한쪽으로만 삽입된 경우 O(N)`
-   최악의 경우를 방지하는 방법: 자가 균형 트리(Balanced Tree)
    -   `AVL 트리`: 왼쪽과 오른쪽 자식의 높이 차이가 1이하일 것을 요구, 삭제/추가 시에 재정렬을 통해 높이를 일정하게 유지, 레드 블랙 트리보다 엄격
    -   `레드 블랙 트리`: 모든 노드가 빨강 또는 검정의 색을 갖는 트리로 최장 경로의 거리는 최단 경로의 거리의 두 배 이상이 될 수 없음, 삭제/추가 시에 재정렬과 색깔 재배치를 통해 규칙을 유지

## Graph 자료구조

-   정점과 간선으로 이루어진 자료구조

## Graph를 구현하는 두 가지 방법과 장단점

-   `인접 행렬`을 사용하는 방법: 2차원 배열을 사용해 정점들의 연결관계를 파악하는 방법으로, 시간 복잡도 `O(1)`로 연결 관계를 파악할 수 있음, `정점과 엣지가 많을 경우 사용`, 구현 간편, 공간 낭비
-   `인접 리스트`를 사용하는 방법: 각 정점의 adjacent list를 통해서 연결 관계를 파악하는 방법으로, 정점들의 관계를 `O(정점에 연결된 노드의 수)`로 파악하는 방법, `정점과 엣지가 적을 경우 사용`, 공간 낭비 적음, 탐색 시간이 느림, 구현 어려움

## AJAX란 무엇인가?
Asynchronous Javascript And XML의 약자로, 비동기적으로 JS를 사용해서 데이터를 받아와 동적으로 DOM을 갱신 및 조작하는 웹 개발 기법을 의미한다. 여기서 XML이 있는 이유는 예전엔 데이터 포맷으로 XML을 많이 사용했기 때문이다.
